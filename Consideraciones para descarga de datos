##Para la descarga masiva de líneas litorales se usa el algoritmo CoastSat diseñado por Kilian Vos (https://github.com/kvos/CoastSat), rutina creada en Jupyter.
##Las instrucciones de descarga y procesamiento de líneas se encuentran detalladas dentro de su repositorio, pero es necesario remarcar algunos detalles

##RECOMENDACIONES

El área de estudio que idealmente se demarque en un polígono en Google Earth, exportándolo en KML y posteriormente transformarlo a GeoJSON
El algoritmo en teoría es capaz de leer archivos KML, pero en el caso personal no funcionó. Se adjunta rutina en R para transformar dicho archivo a GeoJSON

Por último, al momento de definir el área de estudio, se debe acotar lo que mas se pueda la playa a descargar, producto que la presencia de objetos/formas tales como edificaciones, humedales de marisma, lagunas artificiales, y otros cuerpos de agua; generarán una extracción errónea en las líneas de costa al momento de filtrar.

-------------------------------------------------------------------------

# Instala las librerías si no están instaladas
if (!requireNamespace("sf", quietly = TRUE)) {
  install.packages("sf")
}

# Carga la librería necesaria
library(sf)

# Ruta al archivo KML de entrada y salida (cambiar ruta según usuario/a estime conveniente)
ruta_kml <- "C:/Users/joaquin.valenzuela/Documents/CoastSat kmz/kml/Ohiggins/Punta_de_lobos.kml" #EJEMPLO DE CASO USADO POR EL AUTOR
ruta_geojson <- "C:/Users/joaquin.valenzuela/Documents/CoastSat kmz/geojson/Ohiggins/Punta_de_lobos.geojson" #EJEMPLO DE CASO USADO POR EL AUTOR



# Lee el archivo KML
datos_kml <- st_read(dsn = ruta_kml)

# Convierte a GeoJSON
st_write(datos_kml, dsn = ruta_geojson, driver = "GeoJSON")

-------------------------------------------------------------------------


Luego, ubicar archivo GeoJSON en carpeta "examples" de CoastSat, y en carpeta "data" agregar una carpeta con el nombre del área de interés

Posterior definir parámetros como rango de fechas, misiones a seleccionar, escena de Sentinel-2 para no repetir imágenes, proyección, etc

#IMPORTANTE!! Leer cada línea y descripción de celdas que tiene el algoritmo para un mejor entendimiento de este.

CASO ESPECIAL: Para playas muy pequeñas, modificar en la celda 1.3.2 Shoreline extraction el parámetro 'min_lenght_sl', si no el algoritmo no detectará la línea de costa por sus dimensiones

#IMPORTANTE!! PT2. Al momento de finalizar la descarga de las líneas de costa en la tercera celda del punto 1.3.3 Batch shoreline detection, descargar el archivo en formato puntos (points) y líneas (lines). Dentro de la celda hay un comentario del autor donde se especifica la opción para elegir el formato de descarga.
Una vez descargado un archivo, la celda pasa de asterisco a número, en ese momento se debe cambiar al segundo formato y correr nuevamente la celda. Ambos formatos se guardarán en la carpeta.



EJEMPLO DE LA CELDA. REVISAR SEGUNDA LÍNEA
-------------------------------------------------------------------------
from pyproj import CRS
geomtype = 'lines' # choose 'points' or 'lines' for the layer geometry
gdf = SDS_tools.output_to_gdf(output, geomtype)
if gdf is None:
    raise Exception("output does not contain any mapped shorelines")
gdf.crs = CRS(settings['output_epsg']) # set layer projection
# save GEOJSON layer to file
gdf.to_file(os.path.join(inputs['filepath'], inputs['sitename'], '%s_output_%s.geojson'%(sitename,geomtype)),
                                driver='GeoJSON', encoding='utf-8')

-------------------------------------------------------------------------

