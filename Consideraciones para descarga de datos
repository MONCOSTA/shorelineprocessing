##Para la descarga masiva de líneas litorales se usa el algoritmo CoastSat diseñado por Kilian Vos (https://github.com/kvos/CoastSat), rutina creada en Jupyter.
##Las instrucciones de descarga y procesamiento de líneas se encuentran detalladas dentro de su repositorio, pero es necesario remarcar algunos detalles

##RECOMENDACIONES

El área de estudio que idealmente se demarque en un polígono en Google Earth, exportándolo en KML y posteriormente transformarlo a GeoJSON
El algoritmo en teoría es capaz de leer archivos KML, pero en el caso personal no funcionó. Se adjunta rutina en R para transformar dicho archivo a GeoJSON


-------------------------------------------------------------------------

# Instala las librerías si no están instaladas
if (!requireNamespace("sf", quietly = TRUE)) {
  install.packages("sf")
}

# Carga la librería necesaria
library(sf)

# Ruta al archivo KML de entrada y salida (cambiar ruta según usuario/a estime conveniente)
ruta_kml <- "C:/Users/joaquin.valenzuela/Documents/CoastSat kmz/kml/Ohiggins/Punta_de_lobos.kml" #EJEMPLO DE CASO USADO POR EL AUTOR
ruta_geojson <- "C:/Users/joaquin.valenzuela/Documents/CoastSat kmz/geojson/Ohiggins/Punta_de_lobos.geojson" #EJEMPLO DE CASO USADO POR EL AUTOR



# Lee el archivo KML
datos_kml <- st_read(dsn = ruta_kml)

# Convierte a GeoJSON
st_write(datos_kml, dsn = ruta_geojson, driver = "GeoJSON")

-------------------------------------------------------------------------


Luego, ubicar archivo GeoJSON en carpeta "examples" de CoastSat, y en carpeta "data" agregar una carpeta con el nombre del área de interés

Posterior definir parámetros como rango de fechas, misiones a seleccionar, escena de Sentinel-2 para no repetir imágenes, proyección, etc

#IMPORTANTE!! Leer cada línea y descripción de celdas que tiene el algoritmo para un mejor entendimiento de este.

CASO ESPECIAL: Para playas muy pequeñas, modificar en la celda 1.3.2 Shoreline extraction el parámetro 'min_lenght_sl', si no el algoritmo no detectará la línea de costa por sus dimensiones

